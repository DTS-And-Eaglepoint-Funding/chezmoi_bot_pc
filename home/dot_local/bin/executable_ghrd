#!/bin/bash

VERSION=1.1.3

# Created by argbash-init v2.10.0
# ARG_OPTIONAL_SINGLE([release],[r],[A release version],[latest])
# ARG_OPTIONAL_SINGLE([pat],[t],[GitHub Personal access token])
# ARG_OPTIONAL_SINGLE([artifact],[a],[Artifact name])
# ARG_OPTIONAL_BOOLEAN([regex],[x],[Use regex to search artifact],[off])
# ARG_OPTIONAL_SINGLE([parser],[p],[Use custom jq parser instead of search by artifact name])
# ARG_OPTIONAL_SINGLE([source],[s],[Download Repository Source instead of release artifact],[])
# ARG_OPTIONAL_SINGLE([output],[o],[Downloaded directory],[$(pwd)])
# ARG_OPTIONAL_BOOLEAN([debug],[],[Debug option],[off])
# ARG_TYPE_GROUP_SET([sources],[SOURCE],[source],[zip,tar,],[index])
# ARG_POSITIONAL_SINGLE([repo],[GitHub repository. E.g: zero88/gh-release-downloader])
# ARGBASH_SET_DELIM([ =])
# ARG_OPTION_STACKING([getopt])
# ARG_RESTRICT_VALUES([no-local-options])
# ARG_DEFAULTS_POS()
# ARG_HELP([<GitHub release downloader>])
# ARG_VERSION([echo $0 v$VERSION])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


evaluate_strictness()
{
	[[ "$2" =~ ^-(-(release|pat|artifact|regex|parser|source|output|debug|repo|help|version)$|[rtaxpsohv]) ]] && die "You have passed '$2' as a value of argument '$1', which makes it look like that you have omitted the actual value, since '$2' is an option accepted by this script. This is considered a fatal error."
}

# validators

sources()
{
	local _allowed=("zip" "tar" "") _seeking="$1" _idx=0
	for element in "${_allowed[@]}"
	do
		test "$element" = "$_seeking" && { test "$3" = "idx" && echo "$_idx" || echo "$element"; } && return 0
		_idx=$((_idx + 1))
	done
	die "Value '$_seeking' (of argument '$2') doesn't match the list of allowed values: 'zip', 'tar' and ''" 4
}


begins_with_short_option()
{
	local first_option all_short_options='rtaxpsohv'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_repo=
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_release="latest"
_arg_pat=
_arg_artifact=
_arg_regex="off"
_arg_parser=
_arg_source=
_arg_output="$(pwd)"
_arg_debug="off"


print_help()
{
	printf '%s\n' "<GitHub release downloader>"
	printf 'Usage: %s [-r|--release <arg>] [-t|--pat <arg>] [-a|--artifact <arg>] [-x|--(no-)regex] [-p|--parser <arg>] [-s|--source <SOURCE>] [-o|--output <arg>] [--(no-)debug] [-h|--help] [-v|--version] <repo>\n' "$0"
	printf '\t%s\n' "<repo>: GitHub repository. E.g: zero88/gh-release-downloader"
	printf '\t%s\n' "-r, --release: A release version (default: 'latest')"
	printf '\t%s\n' "-t, --pat: GitHub Personal access token (no default)"
	printf '\t%s\n' "-a, --artifact: Artifact name (no default)"
	printf '\t%s\n' "-x, --regex, --no-regex: Use regex to search artifact (off by default)"
	printf '\t%s\n' "-p, --parser: Use custom jq parser instead of search by artifact name (no default)"
	printf '\t%s\n' "-s, --source: Download Repository Source instead of release artifact. Can be one of: 'zip', 'tar' and '' (no default)"
	printf '\t%s\n' "-o, --output: Downloaded directory (default: '$(pwd)')"
	printf '\t%s\n' "--debug, --no-debug: Debug option (off by default)"
	printf '\t%s\n' "-h, --help: Prints help"
	printf '\t%s\n' "-v, --version: Prints version"
}


parse_commandline()
{
	_positionals_count=0
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-r|--release)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_release="$2"
				shift
				evaluate_strictness "$_key" "$_arg_release"
				;;
			--release=*)
				_arg_release="${_key##--release=}"
				evaluate_strictness "$_key" "$_arg_release"
				;;
			-r*)
				_arg_release="${_key##-r}"
				evaluate_strictness "$_key" "$_arg_release"
				;;
			-t|--pat)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_pat="$2"
				shift
				evaluate_strictness "$_key" "$_arg_pat"
				;;
			--pat=*)
				_arg_pat="${_key##--pat=}"
				evaluate_strictness "$_key" "$_arg_pat"
				;;
			-t*)
				_arg_pat="${_key##-t}"
				evaluate_strictness "$_key" "$_arg_pat"
				;;
			-a|--artifact)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_artifact="$2"
				shift
				evaluate_strictness "$_key" "$_arg_artifact"
				;;
			--artifact=*)
				_arg_artifact="${_key##--artifact=}"
				evaluate_strictness "$_key" "$_arg_artifact"
				;;
			-a*)
				_arg_artifact="${_key##-a}"
				evaluate_strictness "$_key" "$_arg_artifact"
				;;
			-x|--no-regex|--regex)
				_arg_regex="on"
				test "${1:0:5}" = "--no-" && _arg_regex="off"
				;;
			-x*)
				_arg_regex="on"
				_next="${_key##-x}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-x" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-p|--parser)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_parser="$2"
				shift
				evaluate_strictness "$_key" "$_arg_parser"
				;;
			--parser=*)
				_arg_parser="${_key##--parser=}"
				evaluate_strictness "$_key" "$_arg_parser"
				;;
			-p*)
				_arg_parser="${_key##-p}"
				evaluate_strictness "$_key" "$_arg_parser"
				;;
			-s|--source)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_source="$(sources "$2" "source")" || exit 1
				shift
				evaluate_strictness "$_key" "$_arg_source"
				;;
			--source=*)
				_arg_source="$(sources "${_key##--source=}" "source")" || exit 1
				evaluate_strictness "$_key" "$_arg_source"
				;;
			-s*)
				_arg_source="$(sources "${_key##-s}" "source")" || exit 1
				evaluate_strictness "$_key" "$_arg_source"
				;;
			-o|--output)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_output="$2"
				shift
				evaluate_strictness "$_key" "$_arg_output"
				;;
			--output=*)
				_arg_output="${_key##--output=}"
				evaluate_strictness "$_key" "$_arg_output"
				;;
			-o*)
				_arg_output="${_key##-o}"
				evaluate_strictness "$_key" "$_arg_output"
				;;
			--no-debug|--debug)
				_arg_debug="on"
				test "${1:0:5}" = "--no-" && _arg_debug="off"
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			-v|--version)
				echo $0 v$VERSION
				exit 0
				;;
			-v*)
				echo $0 v$VERSION
				exit 0
				;;
			*)
				_last_positional="$1"
				_positionals+=("$_last_positional")
				_positionals_count=$((_positionals_count + 1))
				;;
		esac
		shift
	done
}


handle_passed_args_count()
{
	local _required_args_string="'repo'"
	test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require exactly 1 (namely: $_required_args_string), but got only ${_positionals_count}." 1
	test "${_positionals_count}" -le 1 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect exactly 1 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
	local _positional_name _shift_for=$1
	_positional_names="_arg_repo "

	shift "$_shift_for"
	for _positional_name in ${_positional_names}
	do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash
# Validation of values
_arg_source_index="$(sources "$_arg_source" "source" idx)"

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


# vvv  PLACE YOUR CODE HERE  vvv
# ------------------------------

set -e

NC='\033[0m'       #]
RED='\033[0;31m'   #]
GREEN='\033[32m'   #]
YELLOW='\033[33m'  #]
BLUE='\033[34m'    #]
function error() {
    echo -e "$RED$1$NC"
}

function progress() {
    echo -e "$BLUE$1$NC"
}

function success() {
    echo -e "$GREEN$1$NC"
}

function debug() {
    echo -e "$YELLOW$1$NC"
}

function create_parser() {
    if [[ -n $_arg_source ]]; then
        echo "."
    elif [[ -n $_arg_parser ]]; then
        echo "$_arg_parser"
    else
        local jq_test=""
        [[ $_arg_regex == "on" ]] && jq_test=".name|test(\"$_arg_artifact\"; \"il\")" || jq_test=".name == \"$_arg_artifact\""
        echo ".assets | map(select($jq_test))[0]"
    fi
}

function make_download_url() {
    if [[ -z $_arg_source ]]; then
        echo "$BASE_URL/assets/$1"
    elif [[ $_arg_source == 'zip' ]]; then
        jq -r '.zipball_url' <<< "$1"
    elif [[ $_arg_source == 'tar' ]]; then
        jq -r '.tarball_url' <<< "$1"
    fi
}

function guess_artifact_name() {
    if [[ -z $_arg_source ]]; then
        jq -r '.name' <<< "$1"
    else
        local tag=$(jq -r '.tag_name' <<< "$1")
        local ext="zip"
        [[ $_arg_source == "tar" ]] && ext="tar.gz"
        echo "${_arg_repo/\//-}-$tag.$ext"
    fi
}


BASE_URL="https://api.github.com/repos/$_arg_repo/releases"
[[ $_arg_release != "latest" ]] && RELEASE_PATH="tags/$_arg_release" || RELEASE_PATH="$_arg_release"
[[ -z $_arg_pat ]] && AUTH_HEADER="" || AUTH_HEADER="Authorization: Bearer $_arg_pat"

progress "Searching release '$_arg_release' in repository '$_arg_repo'..."
[[ -z $RANDOM ]] && suffix=$(date +%s%N) || suffix=$RANDOM$RANDOM
OUT=/tmp/ghrd-$suffix.json
HEADERS=( "Accept: application/vnd.github.v3+json" )
[[ -n $AUTH_HEADER ]] && HEADERS+=( "$AUTH_HEADER" )

STATUS=$(curl "${HEADERS[@]/#/-H}" -sL -w "%{http_code}" -o "$OUT" "$BASE_URL/$RELEASE_PATH")
if [[ ! "$STATUS" =~ ^2[[:digit:]][[:digit:]] ]]; then
    debug "$(<"$OUT")"; rm -rf "$OUT";
    error "Unable found release '$_arg_release' in repository '$_arg_repo'."
    error "HTTP status: $STATUS";
    exit 1;
fi

r=$(jq "$(create_parser)" < "$OUT")
[[ -z $_arg_source ]] && ARTIFACT_ID=$(jq -r '.id' <<< $r) || ARTIFACT_ID=$r
ARTIFACT_NAME=$(guess_artifact_name "$r")
DOWNLOAD_URL=$(make_download_url "$ARTIFACT_ID")

[[ $_arg_debug == "off" ]] && rm -rf "$OUT"
[[ $_arg_debug == "on" ]] && debug "HTTP Response is dump at $OUT"

[[ -z $ARTIFACT_ID ]] || [[ $ARTIFACT_ID == null ]] && { error "Not Found artifact '$_arg_artifact' with regex option '$_arg_regex'"; exit 2; }
success "Found artifact '$ARTIFACT_NAME' in '$_arg_repo:$_arg_release'."

HEADERS=()
[[ -z $_arg_source ]] && HEADERS+=( "Accept: application/octet-stream" )
[[ -n $AUTH_HEADER ]] && HEADERS+=( "$AUTH_HEADER" )
OUT="$_arg_output/$ARTIFACT_NAME"

echo
progress "Downloading '$ARTIFACT_NAME' to '$_arg_output'..."
STATUS=$(curl "${HEADERS[@]/#/-H}" -L -w "%{http_code}" -o "$OUT" "$DOWNLOAD_URL")
if [[ ! "$STATUS" =~ ^2[[:digit:]][[:digit:]] ]]; then
    debug "$(<"$OUT")"; rm -rf "$OUT";
    error "Unable download artifact '$ARTIFACT_NAME'.";
    error "HTTP status: $STATUS";
    exit 3;
fi
echo "--------------------------------------------------------------------------------"
echo "File: $(ls -lh $OUT | awk '{print $9 " " $5}')"
success "Finish!!!"

# ^^^  TERMINATE YOUR CODE BEFORE THE BOTTOM ARGBASH MARKER  ^^^

# ] <-- needed because of Argbash
